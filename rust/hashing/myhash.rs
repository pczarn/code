#![feature(globs, macro_rules, default_type_params, asm, if_let, old_orphan_check)]

// extern crate core;
extern crate test;

//use core::prelude::*;
use test::black_box;
use std::mem;

// use core::default::Default;

// use std::hash::{Hash, Hasher, Writer};
use std::default::Default;
use std::num::{Int, ToPrimitive};
use std::ops::Shr;
use std::{option, str, slice};
use std::mem::size_of;
use std::iter::{FlatMap, Cloned, Chain, repeat, ExactSizeIterator, AdditiveIterator};

use self::test::Bencher;

/// A hashable type.
pub trait Hash {
    type Contents: Iterator<Item=u8>;
    fn as_byte_contents(&self) -> (<Self as Hash>::Contents, usize);
}

/// A trait which represents the ability to hash an arbitrary stream of bytes.
pub trait Hasher {
    /// Result type of one run of hashing generated by this hasher.
    type Output;

    /// Resets this hasher back to its initial state (as if it were just
    /// created).
    fn reset(&mut self);

    /// Completes a round of hashing, producing the output hash generated.
    fn hash<T: Iterator<Item=u8>>(&mut self, iter: T, length: usize) -> Self::Output;
}

// /// A common bound on the `Hasher` parameter to `Hash` implementations in order
// /// to generically hash an aggregate.
// #[unstable(feature = "hash",
//            reason = "this trait will likely be replaced by io::Writer")]
// #[allow(missing_docs)]
// pub trait Writer {
//     fn write(&mut self, bytes: &[u8]);
// }

/// Hash a value with the default SipHasher algorithm (two initial keys of 0).
///
/// The specified value will be hashed with this hasher and then the resulting
/// hash will be returned.
pub fn hash<T: Hash, H: Hasher + Default>(value: &T) -> H::Output {
    let mut h: H = Default::default();
    // value.hash(&mut h);
    let (iter, len) = value.as_byte_contents();
    h.hash(iter, len)
}

//////////////////////////////////////////////////////////////////////////////

type IntIter<'a, T> = IntContents<T>;

macro_rules! impl_hash {
    ($ty:ident, $uty:ident) => {
        impl<'a> Hash for $ty {
            type Contents = IntIter<'a, $ty>;
            // type Contents = slice::IntoIter<u8>;
            #[inline(always)]
            fn as_byte_contents(&self) -> (IntIter<'a, $ty>, usize) {// slice::IntoIter<u8> {
                // let a: [u8; ::std::$ty::BYTES] = unsafe {
                //     mem::transmute((*self as $uty).to_le() as $ty)
                // };
                // state.write(&a)
                // unsafe {
                //     slice::from_raw_parts(*self as *const _ as *const u8, size_of::<$ty>()).iter().cloned()
                // }
                // a.into_iter()
                (IntContents {
                    val: *self,
                    len: size_of::<$ty>(),
                }, size_of::<$ty>())
            }
        }
    }
}

impl_hash! { u8, u8 }
impl_hash! { u16, u16 }
impl_hash! { u32, u32 }
impl_hash! { u64, u64 }
impl_hash! { usize, usize }
impl_hash! { i8, u8 }
impl_hash! { i16, u16 }
impl_hash! { i32, u32 }
impl_hash! { i64, u64 }
impl_hash! { isize, usize }

impl Hash for bool {
    type Contents = option::IntoIter<u8>;
    #[inline]
    fn as_byte_contents(&self) -> (option::IntoIter<u8>, usize) {
        (Some(*self as u8).into_iter(), 1)
    }
}

impl<'a> Hash for &'a char {
    type Contents = <&'a u32 as Hash>::Contents;
    #[inline]
    fn as_byte_contents(&self) -> (<&'a u32 as Hash>::Contents, usize) {
        let r: &'a u32 = unsafe { mem::transmute(self) };
        r.as_byte_contents()
    }
}

impl<'a> Hash for &'a str {
    // type Contents = StrContents<'a>;
    type Contents = Chain<str::Bytes<'a>, option::IntoIter<u8>>;
    #[inline]
    fn as_byte_contents(&self) -> (Chain<str::Bytes<'a>, option::IntoIter<u8>>, usize) {
        // StrContents {
        //     bytes: self.bytes(),
        //     mark: true,
        // }
        (self.bytes().chain(Some(0xff).into_iter()), self.len() + 1)
    }
}

// struct StrContents<'a> {
//     bytes: str::Bytes<'a>,
//     mark: bool,
// }

// impl<'a> Iterator for StrContents<'a> {
//     type Item = u8;
//     fn next(&mut self) -> Option<u8> {
//         self.bytes.next().or(
//             if self.mark {
//                 self.mark = false; Some(0xff)
//             } else {
//                 None
//             }
//         )
//     }
// }

// macro_rules! impl_hash_tuple {
//     () => (
//         impl Hash for () {
//             type Contents = option::IntoIter<u8>;
//             #[inline]
//             fn as_byte_contents(&self) -> option::IntoIter<u8> { None.into_iter() }
//         }
//     );

//     ( $($name:ident)+) => (
//         impl<$($name: Hash),*> Hash for ($($name,)*) {
//             type Contents = Chain<Chain<A, B>, C>;
//             #[inline]
//             #[allow(non_snake_case)]
//             fn as_byte_contents(&self, state: &mut S) {
//                 match *self {
//                     ($(ref $name,)*) => {
//                         $(
//                             $name.hash(state);
//                         )*
//                     }
//                 }
//             }
//         }
//     );
// }

// impl_hash_tuple! {}
// impl_hash_tuple! { A }
// impl_hash_tuple! { A B }
// impl_hash_tuple! { A B C }
// impl_hash_tuple! { A B C D }
// impl_hash_tuple! { A B C D E }
// impl_hash_tuple! { A B C D E F }
// impl_hash_tuple! { A B C D E F G }
// impl_hash_tuple! { A B C D E F G H }
// impl_hash_tuple! { A B C D E F G H I }
// impl_hash_tuple! { A B C D E F G H I J }
// impl_hash_tuple! { A B C D E F G H I J K }
// impl_hash_tuple! { A B C D E F G H I J K L }

// struct ExactSize<T>(T, usize);

// impl<T: Iterator> Iterator for ExactSize<T> {
//     type Item = T::Item;
//     #[inline(always)]
//     fn next(&mut self) -> Option<T::Item> {
//         self.0.next()
//     }
// }

// impl<T: Iterator> ExactSizeIterator for ExactSize<T> {
//     #[inline]
//     fn len(&self) -> usize {
//         self.1
//     }
// }

// type SliceContents<'a, T, U> = Chain<Cloned<slice::Iter<'a, u8>>,
// type SliceContents<'a, T, U> = Chain<UsizeContents,
type SliceContents<'a, T, U> = Chain<Cloned<slice::Iter<'a, u8>>,//IntContents<usize>,
                                     // FlatMap<slice::Iter<'a, T>,
                                     //         U,
                                     //         fn(arg: &'a T) -> U>>;
                                     AryContents<'a, T, U>>;

impl<'a, T: 'a, U: Iterator<Item=u8>> Hash for &'a [T] where &'a T: Hash<Contents=U> {
    type Contents = SliceContents<'a, T, U>;
    #[inline]
    fn as_byte_contents(&self) -> (SliceContents<'a, T, U>, usize) {
        let this: &'a std::raw::Slice<T> = unsafe { mem::transmute(self) };
        let len: &'a [u8; ::std::usize::BYTES] = unsafe { mem::transmute(&this.len) };
        // self.len().as_byte_co(state);
        #[inline(always)]
        fn f<'a, U: Iterator<Item=u8>, T>(arg: &'a T) -> U where &'a T: Hash<Contents=U> {
            arg.as_byte_contents().0
        }
        let f = f as fn(arg: &'a T) -> U;
        // (&this.len).as_byte_contents().chain(self.iter().flat_map(f))
        (
            // IntContents {
            //     val: self.len(),
            //     len: size_of::<usize>(),
            // }.chain(self.iter().flat_map(f)),
            // len.iter().cloned().chain(self.iter().flat_map(f)),
            len.iter().cloned().chain(AryContents { iter: self.iter(), contents: None }),
            size_of::<usize>() + self.iter().map(|i| i.as_byte_contents().1).sum()
        )
        // println!("in flat_map");
        // None.into_iter().chain(self.iter().flat_map(f))
    }
}

struct AryContents<'a, T: 'a, U> {
    iter: slice::Iter<'a, T>,
    contents: Option<U>,
}

impl<'a, T: 'a, U> Iterator for AryContents<'a, T, U>
    where &'a T: Hash<Contents=U>,
          U: Iterator<Item=u8>,
{
    type Item = u8;
    #[inline(always)]
    fn next(&mut self) -> Option<u8> {
        loop {
            if let Some(ref mut inner) = self.contents {
                return inner.by_ref().next();
            }
            match self.iter.next() {
                None => return None,
                Some(other) => self.contents = Some(other.as_byte_contents().0),
            }
        }
    }
}

struct IntContents<T> {
    val: T,
    len: usize,
}

impl<T: Int + ToPrimitive + Shr<usize>> Iterator for IntContents<T> {
    type Item = u8;
    #[inline(always)]
    fn next(&mut self) -> Option<u8> {
        if self.len == 0 {
            None
        } else {
            self.len -= 1;
            let r = self.val.to_u8().unwrap();
            self.val = self.val.shr(8);
            Some(r)
        }
    }
}

impl<T: Int + ToPrimitive + Shr<usize>> ExactSizeIterator for IntContents<T> {
    fn len(&self) -> usize {
        self.len
    }
}

impl<'a, T: ?Sized, U: Iterator<Item=u8>> Hash for &'a T where T: Hash<Contents=U> {
    type Contents = U;
    #[inline]
    fn as_byte_contents(&self) -> (U, usize) {
        (*self).as_byte_contents()
    }
}

impl<'a, T: ?Sized, U: Iterator<Item=u8>> Hash for &'a mut T where T: Hash<Contents=U> {
    type Contents = U;
    #[inline]
    fn as_byte_contents(&self) -> (U, usize) {
        (*self).as_byte_contents()
    }
}

/// An implementation of SipHash 2-4.
///
/// See: http://131002.net/siphash/
///
/// Consider this as a main "general-purpose" hash for all hashtables: it
/// runs at good speed (competitive with spooky and city) and permits
/// strong _keyed_ hashing. Key your hashtables from a strong RNG,
/// such as `rand::Rng`.
///
/// Although the SipHash algorithm is considered to be cryptographically
/// strong, this implementation has not been reviewed for such purposes.
/// As such, all cryptographic uses of this implementation are strongly
/// discouraged.
pub struct SipHasher {
    k0: u64,
    k1: u64,
    length: uint, // how many bytes we've processed
    v0: u64,      // hash state
    v1: u64,
    v2: u64,
    v3: u64,
    tail: u64, // unprocessed bytes le
    ntail: uint,  // how many bytes in tail are valid
}

// sadly, these macro definitions can't appear later,
// because they're needed in the following defs;
// this design could be improved.

macro_rules! u8to64_le {
    ($buf:expr, $i:expr) =>
    ($buf[0+$i] as u64 |
     ($buf[1+$i] as u64) << 8 |
     ($buf[2+$i] as u64) << 16 |
     ($buf[3+$i] as u64) << 24 |
     ($buf[4+$i] as u64) << 32 |
     ($buf[5+$i] as u64) << 40 |
     ($buf[6+$i] as u64) << 48 |
     ($buf[7+$i] as u64) << 56);
    ($buf:expr, $i:expr, $len:expr) =>
    ({
        let mut t = 0;
        let mut out = 0u64;
        while t < $len {
            out |= ($buf[t+$i] as u64) << t*8;
            t += 1;
        }
        out
    });
}

macro_rules! rotl {
    ($x:expr, $b:expr) =>
    (($x << $b) | ($x >> (64 - $b)))
}

macro_rules! compress {
    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>
    ({
        $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;
        $v0 = rotl!($v0, 32);
        $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;
        $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;
        $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;
        $v2 = rotl!($v2, 32);
    })
}

impl SipHasher {
    /// Creates a new `SipHasher` with the two initial keys set to 0.
    #[inline]
    pub fn new() -> SipHasher {
        SipHasher::new_with_keys(0, 0)
    }

    /// Creates a `SipHasher` that is keyed off the provided keys.
    #[inline]
    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {
        let mut state = SipHasher {
            k0: key0,
            k1: key1,
            length: 0,
            v0: 0,
            v1: 0,
            v2: 0,
            v3: 0,
            tail: 0,
            ntail: 0,
        };
        state.reset();
        state
    }

    // /// Returns the computed hash.
    // #[unstable(feature = "hash")]
    // #[deprecated(since = "1.0.0", reason = "renamed to finish")]
    // pub fn result(&self) -> u64 { self.finish() }
}

// impl Writer for SipHasher {
//     #[inline]
//     fn write(&mut self, msg: &[u8]) {
//         let length = msg.len();
//         self.length += length;

//         let mut needed = 0;

//         if self.ntail != 0 {
//             needed = 8 - self.ntail;
//             if length < needed {
//                 self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;
//                 self.ntail += length;
//                 return
//             }

//             let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;

//             self.v3 ^= m;
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             self.v0 ^= m;

//             self.ntail = 0;
//         }

//         // Buffered tail is now flushed, process new input.
//         let len = length - needed;
//         let end = len & (!0x7);
//         let left = len & 0x7;

//         let mut i = needed;
//         while i < end {
//             let mi = u8to64_le!(msg, i);

//             self.v3 ^= mi;
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             self.v0 ^= mi;

//             i += 8;
//         }

//         self.tail = u8to64_le!(msg, i, left);
//         self.ntail = left;
//     }
// }

struct Chunks8<T> {
    iter: T,
}

impl<T: Iterator<Item=u8>> Iterator for Chunks8<T> {
    type Item = u64;
    #[inline(never)]
    fn next(&mut self) -> Option<u64> {
        // let ary = 
        //     [self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),
        //      self.iter.next().unwrap_or(0),];

        // Some(u8to64_le!(ary, 0))
        match self.iter.next() {
            Some(mi) => {
                // let mut mi = mi as u64;
                let mut msg = [mi, 0, 0, 0, 0, 0, 0, 0];
                for (i, x) in (1u..8).zip(self.iter.by_ref()) {
                    // mi <<= 8;
                    // mi |= self.iter.next().unwrap_or(0) as u64;
                    // mi |= x as u64;
                    msg[i] = x;
                }
                // Some(mi)
                Some(u8to64_le!(msg, 0))
            }
            None => None
        }

        // let mut mi = 0;
        // for _ in 0..8 {
        //     mi |= self.iter.next().unwrap_or(0) as u64;
        //     mi <<= 8;
        // }
        // Some(mi)
    }
}

impl Hasher for SipHasher {
    type Output = u64;

    fn reset(&mut self) {
        self.length = 0;
        self.v0 = self.k0 ^ 0x736f6d6570736575;
        self.v1 = self.k1 ^ 0x646f72616e646f6d;
        self.v2 = self.k0 ^ 0x6c7967656e657261;
        self.v3 = self.k1 ^ 0x7465646279746573;
        self.ntail = 0;
    }

    fn hash<T: Iterator<Item=u8>>(&mut self, mut iter: T, mut length: usize) -> u64 {
        // let mut length = 0;
        // println!("{}", length);
        // let mut i = iter.fuse();
        let mut v0 = self.v0;
        let mut v1 = self.v1;
        let mut v2 = self.v2;
        let mut v3 = self.v3;

        let mut iter = Chunks8 { iter: iter };
        let mut mi = 0;
        let mut i = 0;
        // let mut ary = [None, None, None, None, None, None, None, None, ];

        for chunk in iter {
            // let (len, mut mi) = iter.by_ref()
            //                         .take(8)
            //                         .enumerate()
            //                         .fold((0, 0u64), |acc, elem|
            //                             (elem.0 + 1,
            //                              acc.1 | ((elem.1 as u64) << (elem.0 * 8))));
            // iter.next().map(|a| iter.next().map(|b| [a, b])
            // match (iter.next(), iter.next(), iter.next(), iter.next(), iter.next(), iter.next(), iter.next(), iter.next()) {
            // let (len, mut mi) =
            // if let Some(a) = iter.next() {
            //     if let Some(b) = iter.next() {
            //         if let Some(c) = iter.next() {
            //             if let Some(d) = iter.next() {
            //                 if let Some(e) = iter.next() {
            //                     if let Some(f) = iter.next() {
            //                         if let Some(g) = iter.next() {
            //                             if let Some(h) = iter.next() {
            //                                 (8, [a, b, c, d, e, f, g, h])
            //                             } else {
            //                                 (7, [a, b, c, d, e, f, g, 0])
            //                             }
            //                         } else {
            //                             (6, [a, b, c, d, e, f, 0, 0])
            //                         }
            //                     } else {
            //                         (5, [a, b, c, d, e, 0, 0, 0])
            //                     }
            //                 } else {
            //                     (4, [a, b, c, d, 0, 0, 0, 0])
            //                 }
            //             } else {
            //                 (3, [a, b, c, 0, 0, 0, 0, 0])
            //             }
            //         } else {
            //             (2, [a, b, 0, 0, 0, 0, 0, 0])
            //         }
            //     } else {
            //         (1, [a, 0, 0, 0, 0, 0, 0, 0])
            //     }
            // } else {
            //     (0, [0, 0, 0, 0, 0, 0, 0, 0])
            // };

            // let mut mi = u8to64_le!(mi, 0, len);
            // len = 0;
            // for byte in iter.take(8) {
            //     mi |= (byte as u64) << len*8;
            //     len += 1;
            // }

            // let first = match iter.next() {
            //     Some(x) => x,
            //     None => break
            // };

            // ary = [
            //     Some(first),
            //     iter.next(),
            //     iter.next(),
            //     iter.next(),
            //     iter.next(),
            //     iter.next(),
            //     iter.next(),
            //     iter.next(),
            // ];
            
            // let ary = 
            //     [iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),
            //      iter.next().unwrap_or(0),];
            // {
            //     // let mut iter = iter.take(8).map(|x| {len += 1; x});
            //     // let a = [iter.next(),iter.next(),iter.next(),iter.next(),iter.next(),iter.next(),iter.next(),iter.next(),];

            //     // let mut i = a.iter();
            //     // while let Some(&Some(_)) = i.next() {
            //     //     len += 1;
            //     // }

            //     [first,
            //      ary[1].unwrap_or(0),
            //      ary[2].unwrap_or(0),
            //      ary[3].unwrap_or(0),
            //      ary[4].unwrap_or(0),
            //      ary[5].unwrap_or(0),
            //      ary[6].unwrap_or(0),
            //      ary[7].unwrap_or(0),]
            // };
            // for i in ary.iter() {
            //     if i 
            // }
            // mi = u8to64_le!(ary, 0);

            // length += len as u8;

            // if len != 8 {   
            //     mi |= (length as u64) << 56;
            // }

            // i += 8;

            mi = chunk;

            i += 8;
            if i >= length {
                break;
            }

            v3 ^= mi;
            compress!(v0, v1, v2, v3);
            compress!(v0, v1, v2, v3);
            v0 ^= mi;
        }

        // for i in ary.iter() {
        //     match i {
        //         &Some(_) => length += 1,
        //         _ => break,
        //     }
        // }

        mi |= ((length & 0xff) as u64) << 56;
        v3 ^= mi;
        compress!(v0, v1, v2, v3);
        compress!(v0, v1, v2, v3);
        v0 ^= mi;

        v2 ^= 0xff;
        compress!(v0, v1, v2, v3);
        compress!(v0, v1, v2, v3);
        compress!(v0, v1, v2, v3);
        compress!(v0, v1, v2, v3);

        return v0 ^ v1 ^ v2 ^ v3;
    }
}

impl Clone for SipHasher {
    #[inline]
    fn clone(&self) -> SipHasher {
        SipHasher {
            k0: self.k0,
            k1: self.k1,
            length: self.length,
            v0: self.v0,
            v1: self.v1,
            v2: self.v2,
            v3: self.v3,
            tail: self.tail,
            ntail: self.ntail,
        }
    }
}

impl Default for SipHasher {
    fn default() -> SipHasher {
        SipHasher::new()
    }
}
// use std::slice;
// use std::num::Int;

// /// `SipState` computes a SipHash 2-4 hash over a stream of bytes.
// struct SipState {
//     k0: u64,
//     k1: u64,
//     length: uint, // how many bytes we've processed
//     v0: u64,      // hash state
//     v1: u64,
//     v2: u64,
//     v3: u64,
//     tail: u64, // unprocessed bytes le
//     ntail: uint,  // how many bytes in tail are valid
// }

// impl Copy for SipState {}

// // sadly, these macro definitions can't appear later,
// // because they're needed in the following defs;
// // this design could be improved.

// macro_rules! u8to64_le {
//     ($buf:expr, $i:expr) =>
//     ($buf[0+$i] as u64 |
//      $buf[1+$i] as u64 << 8 |
//      $buf[2+$i] as u64 << 16 |
//      $buf[3+$i] as u64 << 24 |
//      $buf[4+$i] as u64 << 32 |
//      $buf[5+$i] as u64 << 40 |
//      $buf[6+$i] as u64 << 48 |
//      $buf[7+$i] as u64 << 56);
//     ($buf:expr, $i:expr, $len:expr) =>
//     ({
//         let mut t = 0;
//         let mut out = 0u64;
//         while t < $len {
//             out |= $buf[t+$i] as u64 << t*8;
//             t += 1;
//         }
//         out
//     });
// }

// macro_rules! rotl {
//     ($x:expr, $b:expr) =>
//     (($x << $b) | ($x >> (64 - $b)))
// }

// macro_rules! compress {
//     ($v0:expr, $v1:expr, $v2:expr, $v3:expr) =>
//     ({
//         $v0 += $v1; $v1 = rotl!($v1, 13); $v1 ^= $v0;
//         $v0 = rotl!($v0, 32);
//         $v2 += $v3; $v3 = rotl!($v3, 16); $v3 ^= $v2;
//         $v0 += $v3; $v3 = rotl!($v3, 21); $v3 ^= $v0;
//         $v2 += $v1; $v1 = rotl!($v1, 17); $v1 ^= $v2;
//         $v2 = rotl!($v2, 32);
//     })
// }

// impl SipState {
//     /// Creates a `SipState` that is keyed off the provided keys.
//     #[inline]
//     fn new() -> SipState {
//         SipState::new_with_keys(0, 0)
//     }

//     /// Creates a `SipState` that is keyed off the provided keys.
//     #[inline]
//     fn new_with_keys(key0: u64, key1: u64) -> SipState {
//         let mut state = SipState {
//             k0: key0,
//             k1: key1,
//             length: 0,
//             v0: 0,
//             v1: 0,
//             v2: 0,
//             v3: 0,
//             tail: 0,
//             ntail: 0,
//         };
//         state.reset();
//         state
//     }

//     /// Resets the state to its initial state.
//     #[inline]
//     fn reset(&mut self) {
//         self.length = 0;
//         self.v0 = self.k0 ^ 0x736f6d6570736575;
//         self.v1 = self.k1 ^ 0x646f72616e646f6d;
//         self.v2 = self.k0 ^ 0x6c7967656e657261;
//         self.v3 = self.k1 ^ 0x7465646279746573;
//         self.ntail = 0;
//     }

//     // /// Returns the computed hash.
//     // #[inline(always)]
//     // fn result(&self) -> u64 {
//     //     let mut v0 = self.v0;
//     //     let mut v1 = self.v1;
//     //     let mut v2 = self.v2;
//     //     let mut v3 = self.v3;

//     //     let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;

//     //     v3 ^= b;
//     //     compress!(v0, v1, v2, v3);
//     //     compress!(v0, v1, v2, v3);
//     //     v0 ^= b;

//     //     v2 ^= 0xff;
//     //     compress!(v0, v1, v2, v3);
//     //     compress!(v0, v1, v2, v3);
//     //     compress!(v0, v1, v2, v3);
//     //     compress!(v0, v1, v2, v3);

//     //     v0 ^ v1 ^ v2 ^ v3
//     // }
// }

// impl Writer for SipState {
//     //#[inline]
//     fn write(&mut self, msg: &[u8]) {
//         // println!("{}", msg);
//         let length = msg.len();
//         self.length += length;

//         let mut needed = 0u;

//         if self.ntail != 0 {
//             needed = 8 - self.ntail;
//             if length < needed {
//                 self.tail |= u8to64_le!(msg, 0, length) << 8*self.ntail;
//                 self.ntail += length;
//                 return
//             }

//             let m = self.tail | u8to64_le!(msg, 0, needed) << 8*self.ntail;

//             self.v3 ^= m;
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             self.v0 ^= m;

//             self.ntail = 0;
//         }

//         // Buffered tail is now flushed, process new input.
//         let len = length - needed;
//         let end = len & (!0x7);
//         let left = len & 0x7;

//         let mut i = needed;
//         while i < end {
//             let mi = u8to64_le!(msg, i);

//             self.v3 ^= mi;
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             compress!(self.v0, self.v1, self.v2, self.v3);
//             self.v0 ^= mi;

//             i += 8;
//         }

//         self.tail = u8to64_le!(msg, i, left);
//         self.ntail = left;
//     }
// }

// impl Clone for SipState {
//     #[inline]
//     fn clone(&self) -> SipState {
//         *self
//     }
// }

// impl Default for SipState {
//     #[inline]
//     fn default() -> SipState {
//         SipState::new()
//     }
// }

// /// `SipHasher` computes the SipHash algorithm from a stream of bytes.
// #[deriving(Clone)]
// #[allow(missing_copy_implementations)]
// struct SipHasher {
//     k0: u64,
//     k1: u64,
// }

// impl SipHasher {
//     /// Creates a `Sip`.
//     #[inline]
//     fn new() -> SipHasher {
//         SipHasher::new_with_keys(0, 0)
//     }

//     /// Creates a `Sip` that is keyed off the provided keys.
//     #[inline]
//     fn new_with_keys(key0: u64, key1: u64) -> SipHasher {
//         SipHasher {
//             k0: key0,
//             k1: key1,
//         }
//     }
// }

// // impl Hasher<SipState> for SipHasher {
// //     #[inline]
// //     fn hash<Sized? T: Hash<SipState>>(&self, value: &T) -> u64 {
// //         let mut state = SipState::new_with_keys(self.k0, self.k1);
// //         value.hash(&mut state);
// //         state.result()
// //     }
// // }

// // impl Default for SipHasher {
// //     #[inline]
// //     fn default() -> SipHasher {
// //         SipHasher::new()
// //     }
// // }

// // /// Hashes a value using the SipHash algorithm.
// // #[inline]
// // fn hash<Sized? T: Hash<SipState>>(value: &T) -> u64 {
// //     let mut state = SipState::new();
// //     value.hash(&mut state);
// //     state.result()
// // }

// /// Hashes a value using the SipHash algorithm.
// // #[inline]
// fn myhash<Sized? T: MyHash<SipState>>(value: &T) -> u64 {
//     let mut state = SipState::new();
//     // let mut sli = None;
//     let mut sli: &[u8] = &[];
//     let mut sli = Some(sli);
//     value.myhash(&mut state, &mut sli);

//     println!("{} {}", sli, state.length);

//     let mut b: u64 = if let Some(msg) = sli {
//         unsafe {
//             state.write(slice::from_raw_buf(mem::transmute(&msg.as_ptr()), msg.len() & !7));
//         }
//         let length = msg.len() & 7;
//         (((state.length + msg.len()) as u64 & 0xff) << 56) | u8to64_le!(msg, msg.len() & !7, length)
//     } else {
//         (state.length as u64 & 0xff) << 56
//     };

//     let mut v0 = state.v0;
//     let mut v1 = state.v1;
//     let mut v2 = state.v2;
//     let mut v3 = state.v3;

//     v3 ^= b;
//     compress!(v0, v1, v2, v3);
//     compress!(v0, v1, v2, v3);
//     v0 ^= b;

//     v2 ^= 0xff;
//     compress!(v0, v1, v2, v3);
//     compress!(v0, v1, v2, v3);
//     compress!(v0, v1, v2, v3);
//     compress!(v0, v1, v2, v3);

//     v0 ^ v1 ^ v2 ^ v3
// }

// // /// Hashes a value with the SipHash algorithm with the provided keys.
// // #[inline]
// // fn hash_with_keys<Sized? T: Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {
// //     let mut state = SipState::new_with_keys(k0, k1);
// //     value.hash(&mut state);
// //     state.result()
// // }

// struct CustomSlice<'a> { sli: &'a [u8] }

// impl<'a, S: Writer> Hash<S> for CustomSlice<'a> {
//     #[inline(always)]
//     fn hash(&self, state: &mut S) {
//         self.sli.len().hash(state);
//         for &v in self.sli.iter() {
//             state.write(&[v]);
//         }
//     }
// }

// trait MyHash<S = SipState> for Sized? {
//     fn myhash<'a>(&'a self, state: &mut S, sli: &mut Option<&'a [u8]>);
// }

// impl<'a, S: Writer> MyHash<S> for &'a [u8] {
//     #[inline(always)]
//     fn myhash<'b>(&'b self, state: &mut S, sli: &mut Option<&'b [u8]>) {
//         //if !sli.is_empty() { state.write(*sli); }
//         let mut sli2 = None;
//         let len2 = self.len();
//         len2.myhash(state, &mut sli2);
//         if let Some(sli2) = sli2 { state.write(sli2); }
//         for v in self.iter() {
//             v.myhash(state, sli);
//             //state.write(&[v]);
//         }
//     }
// }

// macro_rules! impl_hash {
//     ($ty:ident, $uty:ident) => {
//         impl<S: Writer> MyHash<S> for $ty {
//             #[inline]
//             fn myhash<'a>(&'a self, state: &mut S, sli: &mut Option<&'a [u8]>) {
//                 if (*self as $uty).to_le() == (*self as $uty) {
//                     let a = unsafe {
//                         slice::from_raw_buf(mem::transmute(&self), mem::size_of::<$uty>())
//                     };
//                     // let m = match sli {
//                     //     &Some(sli) => a.as_slice().as_ptr() == unsafe { sli.as_ptr().offset(sli.len() as int) },
//                     //     _ => false
//                     // };
//                     match sli { &Some(ref mut sli) if a.as_slice().as_ptr() == unsafe { sli.as_ptr().offset(sli.len() as int) } => {
//                         *sli = unsafe {
//                             slice::from_raw_buf(mem::transmute(&sli.as_ptr()), sli.len() + a.len())
//                         };
//                     } &Some(ref mut sl) => {
//                         state.write(*sl);
//                         *sl = a;
//                     } &None => {
//                         *sli = Some(a);
//                     } }
//                 } else {
//                     let a: [u8; ::core::$ty::BYTES] = unsafe {
//                         mem::transmute((*self as $uty).to_le() as $ty)
//                     };
//                     if let Some(sli) = *sli { state.write(sli); }
//                     state.write(a.as_slice());
//                     *sli = None;
//                 }
//             }
//         }
//     }
// }

// // fn myhash<'a>(&'a self, state: &mut S, msg: &mut Option<&'a [u8]>) {
// //     if (*self as T).to_le() == *self as T { unsafe {
// //         let a = slice::from_raw_buf(mem::transmute(&self), mem::size_of::<T>());
// //         let a_ptr = a.as_ptr();

// //         match msg {
// //             &Some(ref mut m) if a_ptr == m.as_ptr().offset(m.len() as int) => {
// //                 *msg = slice::from_raw_buf(mem::transmute(&m.as_ptr()),
// //                                            m.len() + a.len());
// //             }
// //             _ => {
// //                 if let Some(msg_part) = *msg { state.write(msg_part); }
// //                 *msg = Some(a);
// //             }
// //         }
// //     } } else {
// //         let a: [u8, ..::core::$ty::BYTES] = unsafe {
// //             mem::transmute((*self as T).to_le() as $ty)
// //         };
// //         if let Some(msg_part) = *msg { state.write(msg_part); }
// //         state.write(a.as_slice());
// //         *msg = None;
// //     }
// // }

// // for primitive integer types
// // impl<S: Writer> MyHash<S> for T
// // fn myhash<'a>(&'a self, state: &mut S, msg: &mut Option<&'a [u8]>) {
// //     if (*self as T).to_le() == *self as T {
// //         let a = unsafe {
// //             slice::from_raw_buf(mem::transmute(self), mem::size_of::<T>())
// //         };

// //         let msg_end = unsafe { msg.as_ptr().offset(sli.len() as int) };
// // let a_ptr = a.as_slice().as_ptr();

// //         match msg {
// //             &Some(ref mut msg_part) if a_ptr == msg_end => {
// //                 *msg = unsafe {
// //                     slice::from_raw_buf(mem::transmute(&msg_part.as_ptr()),
// //                                         msg_part.len() + a.len())
// //                 };
// //             }
// //             _ => {
// //                 if let Some(msg_part) = *msg { state.write(msg_part); }
// //                 *msg = Some(a);
// //             }
// //         }
// //     } else {
// //         let a: [u8; ::core::$ty::BYTES] = unsafe {
// //             mem::transmute((*self as T).to_le() as $ty)
// //         };
// //         if let Some(msg_part) = *msg { state.write(msg_part); }
// //         state.write(a.as_slice());
// //         *msg = None;
// //     }
// // }

// impl_hash!(u8, u8);
// impl_hash!(u16, u16);
// impl_hash!(u32, u32);
// impl_hash!(u64, u64);
// impl_hash!(uint, uint);
// impl_hash!(i8, u8);
// impl_hash!(i16, u16);
// impl_hash!(i32, u32);
// impl_hash!(i64, u64);
// impl_hash!(int, uint);

// struct IState<'a> {
//     r: Option<&'a uint>,
// }

// struct Inner<T> {
//     inner: T,
//     smth: uint,
// }

// impl<T> Inner<T> {
//     fn foo<'a>(&'a self, state: &mut IState<'a>) {
//         state.r = Some(&self.smth);
//     }
// }

    // // Test for slice join
    // let sli1 = val.sli.slice_to(2);
    // let sli2 = val.sli.slice_from(2);
    // let sli1end = unsafe { sli1.as_ptr().offset(sli1.len() as int) };
    // if sli1end == sli2.as_ptr() {
    //     unsafe { asm!("" :: "r"(valr) :: "volatile"); }
    // }
    // let mut ist = IState { r: None };
    // let inne = Inner { inner: 1u, smth: 2u };
    // inne.foo(&mut ist);
    
    // let h = myhash(valr);
    //let h = hash(&valr.sli[0]);
    // let mut h = hash(valr);

        // let m = match sli {
        //     &Some(sli) => a.as_slice().as_ptr() == unsafe { sli.as_ptr().offset(sli.len() as int) },
        //     _ => false
        // };

// fn main() {
//     let mut val_slice: &[u8] = &[12, 23, 34, 45];
//     // let mut val_raw = (val_slice.as_ptr(), val_slice.len());
//     let mut val = &mut val_slice;
//     unsafe { asm!("" : "+r"(val) ::: "volatile"); }
//     // let (val_ptr, val_len) = *val;

//     let mut state: Option<MySlice> = None;

//     let mut val_ptr = val.as_ptr();

//     // for v in val.slice_to(4).iter() { unsafe {
//         // let val1 = val.as_ptr();
//     for idx in range(0, 4) { unsafe {
//         // let next_sli = slice::from_raw_buf(mem::transmute(&v), 1);
//         // let val_ptr: *const u8 = val.as_ptr().offset(idx);

//         match state {
//             Some(ref mut current) => {
//                 // let current_end = current_sli.as_ptr()
//                 //                              .offset(current_sli.len() as int);

//                 if val_ptr == current.end {
//                     current.len += 1;
//                     current.end = current.end.offset(1);
//                     // *current = slice::from_raw_buf(mem::transmute(&current_sli.as_ptr()),
//                     //                                    current_sli.len() + next_sli.len());
//                 } else {
//                     black_box(&*current);
//                     *current = MySlice {
//                         start: val_ptr,
//                         len: 1,
//                         end: val_ptr.offset(1)
//                     };
//                 }
//             }
//             None => {
//                 state = Some(MySlice {
//                     start: val_ptr,
//                     len: 1,
//                     end: val_ptr.offset(1)
//                 });
//             }
//         }
//         val_ptr = val_ptr.offset(1);
//     } }

//     black_box(&state);
//     // unsafe { asm!("" :: "r"(&state) :: "volatile"); }
//     // println!("{}", state);
//     // unsafe { asm!("" :: "r"(&output) :: "volatile"); }

//     //let mut h = hash(valr);
//     //unsafe { asm!("" :: "r"(h) :: "volatile"); }
// }

// fn main() {
//     let mut val_slice: &[u8] = &[12, 23, 34, 45, 12, 23, 34, 45, 12, 23, 34, 45, 12, 23, 34, 45, 12, 23, 34, 45, 12, 23, 34, 45, 12, 23, 34, 45];
//     let mut val = &mut val_slice;
//     unsafe { asm!("" : "+r"(val) ::: "volatile"); }
 
//     let mut state: Option<MySlice> = None;
 
//     let mut val_ptr = val.as_ptr();
 
//     let res = val.iter().fold(state, |acc, elem| unsafe {
//         let val_ptr: *const u8 = elem;

//         match acc {
//             Some(mut current) => {
//                 if val_ptr == current.start.offset(current.len as int) {
//                     current.len += 1;
//                     Some(current)
//                     // current.end = current.end.offset(1);
//                 } else {
//                     // black_box(&current);
//                     Some(MySlice {
//                         start: val_ptr,
//                         len: 1,
//                         // end: val_ptr.offset(1)
//                     })
//                 }

//             }
//             None => {
//                 Some(MySlice {
//                     start: val_ptr,
//                     len: 1,
//                     // end: val_ptr.offset(1)
//                 })
//             }
//         }
//         // val_ptr = val_ptr.offset(1);
//         // r
//     });
 
//     black_box(&res);
//     println!("{}", res);
// }



#[derive(Show)]
pub struct MySlice {
    start: *const u8,
    len: uint,
    // end: *const u8,
}

trait Merger {
    unsafe fn visit(&self, state: &mut MySlice);
}

impl Merger for u8 {
    unsafe fn visit(&self, state: &mut MySlice) {
        let self_ptr = self as *const _ as *const u8;

        if state.start.offset(state.len as int) != self_ptr {
            black_box(&state);
            *state = MySlice {
                start: self_ptr,
                len: 0
            };
        }

        state.len += mem::size_of::<u8>();
    }
}

impl<'a, T: Merger> Merger for &'a [T] {
    unsafe fn visit(&self, state: &mut MySlice) {
        let self_ptr = self.as_ptr() as *const u8;

        if state.start.offset(state.len as int) != self_ptr {
            black_box(&state);
            *state = MySlice {
                start: self_ptr,
                len: 0
            };
        }

        // let mut state = MySlice {
        //     start: self.as_ptr(),
        //     len: 0
        // };
        for elem in self.iter() {
            elem.visit(state);
        }
    }
}

#[inline(never)]
pub fn merge_slice(val: &[u8]) -> MySlice {
    let mut val_ptr = val.as_ptr();
 
    let len = val.len();
    let mut idx = 0;

    // if len == 0 {
    //     return MySlice {
    //         start: val_ptr,
    //         len: 0,
    //         end: val_ptr,
    //     };
    // }

    // len -= 1;

    let mut state = unsafe {
        MySlice {
            start: val_ptr,
            len: 0,
            // end: val_ptr // to the end of the 0 item
        }
    };
    
    // val_ptr = val_ptr.offset(1);

    unsafe {
        while len != idx {
            // let mut flen = 0;
        // loop {
            let mut tmp1 = val_ptr;
            let mut tmp2 = val_ptr;
            loop {
                tmp1 = tmp1.offset(1); // state advance to the end
                tmp2 = tmp2.offset(1); // val ptr to the next item

                idx += 1;
                state.len += 1;

                if tmp1 != tmp2 {
                    // state.len += flen; // len to the end
                    // state.end = tmp1;
                    black_box(&state);
                    val_ptr = tmp2;
                    // tmp1 = tmp2;

                    state = MySlice {
                        start: val_ptr,
                        len: 0,
                        // end: val_ptr,
                    };
                    break;
                }

                if len == idx {
                    // state.len += flen;
                    // state.end = tmp1;
                    return state;
                }
            }
        }
    }

    state
}

#[cfg(check)]
fn main() {
    let mut val_slice: &[u8] = &[12, 23, 34, 45, 12];
    let mut r = &val_slice;
    unsafe { asm!("" : "+r"(r) ::: "volatile"); }

    let mut state = MySlice {
        start: r.as_ptr(),
        len: 0
    };
    unsafe {
        black_box(&(*r).visit(&mut state));
    }
}

#[bench]
fn bench_slice(bench: &mut Bencher) {
    let val: &[u8] = &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ];
    // let mut val: &[&[u8]] = &[&[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ], &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ], &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ]];
    // let mut val = 0u64;
    // let val = "abecadło";
    let mut r = &val;
    unsafe { asm!("" : "+r"(r) ::: "volatile"); }

    bench.iter(||
        hash::<_, SipHasher>(&r)
    )
}

#[bench]
fn bench_std(bench: &mut Bencher) {
    let mut val: &[u8] = &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ];
    // let mut val: &[&[u8]] = &[&[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ], &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ], &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ]];
    // let mut val = 0u64;
    // let val = "abecadło";
    let mut r = &mut val;
    unsafe { asm!("" : "+r"(r) ::: "volatile"); }

    bench.iter(||
        ::std::hash::hash::<_, ::std::hash::SipHasher>(&r)
    )
}

#[cfg(not(check))]
#[cfg(not(test))]
fn main() {
    // let mut val_slice: &[u8] = &[12, 23, 34, 45, 12];
    // let mut val: &[u8] = &[12, 23, 34, 45, 12, 12, 23, 34, 45, 12, ];
    let mut val = 0u64;
    let mut r = &val;
    unsafe { asm!("" : "+r"(r) ::: "volatile"); }

    black_box(&hash::<_, SipHasher>(&val));
    // println!("in main");
    // println!("{} {}", hash::<_, SipHasher>(&val), ::std::hash::hash::<_, ::std::hash::SipHasher>(&val));
    // black_box(&::std::hash::hash::<_, ::std::hash::SipHasher>(&r));
    // black_box(&merge_slice(*r));

    // println!("{}", merge_slice(val_slice));

    // let h: u64 = hash::<&u8, SipHasher>(&&0u8);
    // println!("{}", h);

    // let mut val = &mut val_slice;
    // unsafe { asm!("" : "+r"(val) ::: "volatile"); }
 

    // for _ in range(1, val.len()) { unsafe {
    // // for elem in val.slice_from(1).iter() { unsafe {
    //     // let val_ptr: *const u8 = elem;

    //     if val_ptr == state.end {
    //         state.len += 1;
    //         state.end = state.end.offset(1);
    //         val_ptr = val_ptr.offset(1);
    //     } else {
    //         // black_box(&*current);
    //         state = MySlice {
    //             start: val_ptr,
    //             len: 1,
    //             end: val_ptr.offset(1)
    //         };
    //         val_ptr = 
    //     }
    // } }
 
}
